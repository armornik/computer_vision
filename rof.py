from numpy import *


def denoise(im, U_init, tolerance=0.1, tau=0.125, tv_weight=100):
    """ Реализация модели очистки от шумов Рудина-Ошера-Фатеми
        (ROF) с использованием численного алгоритма, приведенного в формуле А. Шамболя

        Вход: зашумленное изображение (полутоновое), начальная гипотеза о U, вес члена, регуляризующего TV?
        величина шага, допуск в условии остановки

        Выход: очищенное от шума и текстуры изображение, остаточная текстура. """

    m, n = im.shape  # размер зашумленного изображения

    # Инициализация
    U = U_init
    Px = im  # x-компонента двойственной задачи
    Py = im  # y-компонента двойственной задачи
    error = 1

    while (error > tolerance):
        Uold = U

        # Градиент переменной прямой задачи
        GradUx = roll(U, -1, axis=1) - U  # x-компонента градиента U
        GradUy = roll(U, -1, axis=0) - U  # y-компонента градиента U

        # Изменить переменную двойственной задачи
        PxNew = Px + (tau / tv_weight) * GradUx  # не нормализованная изменение х-компоненты
        PyNew = Py + (tau / tv_weight) * GradUy  # не нормализованная изменение у-компоненты
        NormNew = maximum(1, sqrt(PxNew ** 2 + PyNew ** 2))

        Px = PxNew / NormNew  # изменить компоненту х (двойственной задачи)
        Py = PyNew / NormNew  # изменить компоненту у (двойственной задачи)

        # Изменить переменную прямой задачи
        RxPx = roll(Px, 1, axis=1)  # циклический сдвих x-компоненты вдоль оси х
        RyPy = roll(Py, 1, axis=0)  # циклический сдвих у-компоненты вдоль оси у

        DivP = (Px - RxPx) + (Py - RyPy)  # дивергенция двойственного поля
        U = im + tv_weight * DivP  # изменение переменной прямой задачи

        # пересчитать погрешность
        error = linalg.norm(U - Uold) / sqrt(n * m);

    return U, im - U  # очищенное от шумов изображение и остаточная текстура
